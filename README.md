# 进程间通信概述
* 数据传输：一个进程需要将它的数据发送给另一个进程，发送的数据量在一个字节到几兆字节之间
* 共享数据：多个进程想要操作共享数据，一个进程对共享数据的修改，别的进程应该立刻看到。
* 通知时间：一个进程需要向另一个或一组进程发送消息，通知他们发生了某些事件（如进程终止时要通知父进程）
* 资源共享：多个进程之间共享同样的资源，为了做到这一点，需要内核提供锁和同步机制
* 进程控制：有些进程希望完全控制另一个进程的执行(如Debug进程)，此时控制进程希望能够拦截另一个进程的所有陷入的异常，并能够及时指导它的状态改变。

[TOC]
# 进程间通信方式
* 管道(pipe)，有名管道(FIFO)
* 信号(signal)
* 消息队列
* 共享内存
* 信号量
* 套接字(socket)

## 管道
* 管道针对本地计算机的两个进程之间的通信而设计的通信方式，管道建立后，实际获得两个文件描述符：一个用于读取另一个用于写入。
* 常见的IPC机制，通过pipe系统调用。
* 管道单工，数据只能向一个方向流动。双向通信时，需要建立两个管道。
* 数据的读出和写入：一个进程向管道中写的内容被管道另一端的进程读出。写入的内容每次都添加在管道的缓冲区的尾部，每次都是从缓冲区的头部读出数据。
### 管道的分类
* 匿名管道
    * 关系进程，父子或兄弟
    * 由pipe系统调用，管道由父进程建立
    * 管道位于内核空间，其实是一块缓存
* 有名管道（FIFO）
    * 两个没有任何关系的进程之间通信可通过有名管道进行数据传输
    * 通过系统调用mkfifo创建
### 管道创建

```
#include<unistd.h>
int pipe(int fd[2]);
//返回：0成功，-1出错
```
* 两个文件描述符数组
    * fd[0]:pipe的读端
    * fd[1]:pipe的写端


## 共享内存
* 共享内存区域是被多个进程共享的一部分物理内存。
* 多个进程都可以把共享内存**映射**到自己的虚拟空间。所有用户空间的进程要操作共享内存，都要将其映射到自己的虚拟空间，通过映射的虚拟内存空间地址去操作共享内存，从而达到进程间的数据通信。
* 共享内存是进程间共享数据的一种最快的方法，一个进程向共享内存区域写入了数据，共享这个内存区域的所有进程就可以立刻看到其中的内容
* 本身不提供同步机制，可通过信号量进行同步
* 提升数据处理效率，一种**效率最高**的IPC机制
### 共享内存属性信息
```C++
struct shmid_ds{
    struct ipc_perm shm_perm;
    size_t shm_semsz;//共享内存大小   
    pid_t shm_lpid;//最后一次调用系统pid
    pid_t shm_cpid;//pid的创建者的id
    shmatt_t shm_nattch;//和共享内存成功映射的数量
    time_t shm_atime;//最后一个成功映射的时间
    time_t shm_dtime;//最后断开映射的时间
    time_t shm_ctime;//最后改变的时间
}
```
### 共享内存使用步骤
* 使用shmget()函数创建共享内存
* 使用shmat()函数映射共享内存，将这段创建的共享内存映射到具体的进程虚拟内存空间

### 创建共享内存
```C++
#include <sys/shm.h>
itn shmget(key_t key,size_t size,int shmflag);
//返回，成功返回内核中共享内存的表示iD，失败返回-1.
```
* 参数
    * key:用户指定的共享内存键值
    * size:共享内存大小
    * shmflg:IPC_CREAT,IPC_EXCL等权限组合
* erron
    * EINVAL(无效的内存段大小)
    * EEXIST(内存段已经存在，无法创建)
    * EIDRM(内存段已经被删除)
    * ENOENT(内存段不存在)
    * EACCES(权限不够)
    * ENOMEM(没有足够内存创建内存段)

### 共享内存控制
```C++
#include<sys/shm.h>
int shmctl(int shmid,int cmd,struct shmid_ds *buf);
```
* 参数
    * shmid:共享内存ID
    * buf:共享内存属性指针
    * cmd
        * IPC_STAT 获取共享内存段属性
        * IPC_SET 设置共享内存段属性
        * IPC_RMID 删除共享内存段
        * SHM_LOCK 锁定共享内存段页面
        * SHM_UNLOCK 解锁锁定

### 共享内存映射和解除
```
#include<sys/shm.h>
void shmat(int shmid,char *shmaddr,int shmflg);
int shmdt(char  *shmaddr);
//失败返回-1
```
* 参数
    * shmid:共享内存ID
    * shmaddr:映射到进程虚拟内存空间的地址，系统自动分配
    * shmflg:弱shmaddr为0，shmflag也是0
        * SHM_RND
        * SHMLBA 地址为2的次方
        * SHM_RDONLY 只读方式连接
* errno
    * EINVAL 无效的IPC ID值或无效的地址
    * ENOMEM 没有足够的内存
    * EACCES 权限不够
* 子进程不继承父进程创建的共享内存，大家是共享的，子进程继承父进程映射的地址。